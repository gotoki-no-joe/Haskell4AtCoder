# 巡回セールスマン問題

（「アルゴリズムロジック」の定式化がアレなので、書下ろしをする。）

重み付き辺の有向グラフに対して、全ての頂点を一度ずつ通り出発点に戻る経路で最小コストのものを見つける問題。

ノード番号は0からn-1までとする。巡回の始点終点を、天下り的にn-1とする。  
さて、ビットDPの集合Sを、ノード番号0からn-2までのノード集合とする。そして、DPで保存する値を、単一の値ではなく、ノード番号vをキーとするIntMapとする。そして、Mapが割り当てる値を、「始点n-1から出発し、Sの要素を一度ずつ辿って、vで終わる経路の最小コスト」とする。vがSに含まれないときそのようなコストはないのでMapのdomainから除外する。

グラフそのものは、ノードに対して、そのノードを始点とする辺の情報を返すIntMapで表せる。そのIntMapは、終点とする辺に対して、コストを割り当てるIntMapを割り当てる。

というスタイルでグラフを表現すると、存在しない辺についてコストを調べるとNothingになるので分岐したりするのが面倒なので、辺がない、または、経路がない、というNothingを-1で表し、普通のコストを0以上の数で表す。それを扱う演算は-1を特別視するようにカスタムしたものを用意する。

```haskell
myAdd (-1) _ = -1
myAdd _ (-1) = -1
myAdd x    y = x + y

myMin x (-1) = x
myMin (-1) y = y
myMin x    y = min x y

myMinimum = foldl myMin (-1)
```

こうすると、IntMapを交えずに、全て配列で扱うことができる。  
つまり、ノード集合Sに対するdpを $$dp[S]$$を、Sに含まれる終端ノードvに対して最小コストを割り当てるIntMapという一つの値する代わりに、$$dp[S][v]$$という二次元配列で表現する。しかし概念としてはビットDPのパターンに一致したままである。

### 初期値の設定

$$dp[\emptyset]$$は意味をなさない。ノードが一つも含まれないので、終端ノードとして何一つ考えられないからである。

代わりに、1点集合$$\{v\}$$を考える。これのコストは、始点n-1からの距離である。  
つまり、全てのn-1以外の頂点vについて以下である。  
$$dp[\{v\}][v] = \textrm{cost}(n-1,v)$$  
v以外の頂点については無限大にしておく。

### 漸化式

あるノード集合Sに関する結果は、そこにないノードvを終点とする、より大きなノード集合に関するコストを求める材料になる。  
一点集合でない全てのノード集合Sに対して、初期値を無限大とする。  
$$dp[S][v] = \infty$$　$$|S| > 1$$のとき  
「dpの値の確定した」集合Sに対して、そのSに含まれない全てのノードvに対して、Sからさらにvに至る経路は、いずれかの終端ノード$$u \in S$$からvに移動した経路の最小値になるので、  
$$\textrm{let} \; v \notin S, \textrm{let} \; S' = S \cup \{v\}$$  
$$dp[S'][v] = \min(dp[S'], \min \{ dp[S][u] + \textrm{cost}(u,v) \,|\, u \in S \})$$  
とやってSからさまざまなvを持つS'へ「配る」ことで、S'のコストに関する情報を更新していく。  
この「配る」操作を行ってよいSは、dpの値が確定している必要がある。Sをビット集合で表現したとき、1はノード番号0のみの一点集合なので確定している。  
任意の数nの表すビット集合の全ての部分集合のビット表現はnより小さい（つまり二進数の1をいくつか0に書き換えたものだから）ので、1から順にループで回してゆけば、それらは運のいいことに確定している。  
そして、全ての候補の最小値がdpの確定値であるが、ループがnに至ったとき、全ての候補からの「配る」は済んでいるので、それは正しい値になっている。  
という割とあやうい偶然に守られて、配るDPは成立している。

もっと確実に、一度だけ値を求める、集めるDPで考えたい。  
上の式を$$S'$$を開始点として読むことで、vを持たないSの各uに関するコスト群から集めることで、S',vに関する結果を求めることができる、と読める。  
$$dp[S][v] = \min \{ dp[S-\{v\}][u] + \textrm{cost}(u,v) \,|\, u \in S, u \neq v\}$$  
この右辺は、S,vに関するコストを求める関数として一般化できる。  
$$\textrm{Cost}(S,v) = \min \{ dp[S-\{v\}][u] + \textrm{cost}(u,v) \,|\, u \in S, u \neq v\}$$  
$$dp[S][v] = \left \{ \begin{array}{ll} \textrm{cost}(n-1,v) & \textrm{when} \; S = \{v\} \\  \textrm{Cost}(S,v) & \textrm{when} \; |S| > 1 \\ \end{array} \right .$$

### 最終結果

これでDPにより、n-1以外の頂点を全て経由して、いずれかの頂点で終わる経路のコストがそれぞれ算出できた。それらのいずれかからn-1につないだコストの最小値が、求める結果である。すなわち、全ての頂点集合をVとして、$$\textrm{Cost}(V,n-1)$$を求めればよい。

以上をHaskellにすると次のようになる。`suvstep`が$$\textrm{Cost}$$に相当する。`dpf`が上の漸化式である。

```haskell
compute :: Int -> [[Int]] -> Int
compute n abcs = suvstep abits n1
  where
    n1 = pred n
    n2 = pred n1
    cost = accumArray (flip const) (-1) ((0,0),(n1,n1))
           [((a,b),c) | (a:b:c:_) <- abcs] -- 辺がないとき-1
    abits = 2^n1 - 1 :: Int
    dp = array ((1,0),(abits,n2))
         [((s,v), dpf s v) | s <- [1..abits], v <- [0..n2]]
    suvstep s v = myMinimum [(dp ! (s,u)) `myAdd` (cost ! (u,v)) | u <- [0..n2]]
    dpf s v
      | not $ testBit s v = -1
      | popCount s == 1   = cost ! (n1, head [v | v <- [0..], testBit s v])
      | otherwise         = suvstep (clearBit s v) v
```

（AOJには提出していない）

