# 巡回セールスマン問題 \(bad\)

重み付き辺の有向グラフに対して、全ての頂点を一度ずつ通り出発点に戻る経路で最小コストのものを見つける問題。

とりあえず、配列dの添え字を頂点の部分集合Sとする。  
値は、Sのノードを一度ずつ通り出発点に戻る経路の最小経路、とする。  
  
  
配列dの値は、その経路における最小コスト。  
DPの代表的な問題といいつつ、導入で示した標準形では漸化式を立てられない。  
配列dの添え字を、S : ノードの部分集合、から次元を増やして、Sに含まれる頂点vそれぞれについて、

解説の説明が理解できない...納得いかないというか。  
頂点0から出発して「巡回する」経路、といったら0に戻るということなのか、しかし「最後がv」というのが、vで終わったら巡回していない。  
新たな頂点を加えるとき、Sに含まれるuを選んで、uからvのコストを足しての最小値をS+vのコストとする、だと、vで終わる、0に戻らない経路のコストにしかならない。0....u + v なので。0に戻るためには、0...u..0 なコストから u-0 を引いて u-v + v-0 を足さないとおかしい、と思う。  
そして最終的にd\[A\]\[0\]に答えが入っている、ってそれっぽいけど、上の漸化式の疑問が疑問なので、納得いかない。

配るDP、とは言いえて妙。  
それより、Sの添え字として0はありえないよね。Sが空集合ということだから。  
最初の1つを作るのを、漸化式流用するためにそうする感じ？

読み解いてみよう。  
Sを0から2^n-1まで順に進めている。ビット表現Sに対して、それよりビットが落ちた表現は全てSより小さいから、0から順に調べていくので大丈夫、という議論で。  
そして、vに関して一つずつ調べる。それに対して、uは全て調べて最小値を見つけようとする。  
uの調べるべきは、Sに含まれていて、uからvへの辺があるようなものだけ。  
なので、s .&. vb != 0 && IM.member v \(graph ! u\) なものだけ。  
説明のコードでは、Sが0のでないときは、uがSになくても飛ばさずに続けろと書いてある。結局、頂点0から頂点vに行くコストだけをd\[{v}\]\[v\]にするということのようだ。  
結果はあってるけどダメなタイプのコードだなぁ。

基底の値としては、全ての頂点に対して d\[{v}\]\[v\] = cost\(0,v\) を設定し、それ以外の頂点について漸化式で計算していく、のが正しそうだが、そういう順でやるのが大変なのさ。なんかIM.fromListWith minを使うといい感じにできるかも、と思ったけれど、arrayに敷き詰めないと最終的にあかん気がしなくもない。Vectorにできないから？

```haskell
compute :: Int -> [[Int]] -> Int
compute n edges =
  where
    n1 = pred n
    pow = 2^n-1
    graph = accumArray (uncurry IM.insert) IM.empty (0,n1)
            [(b,c) |[a,b,c] <- edges]
    d = array ((1,0),(pow, n1))
        [((s,v),f s v) | s <- [1..pow], v <- [0..n1]]
    f s v
      | s .&. vb == 0 = maxBound -- より小さい値にしておきたいが
      | popcount s == 1 = -- abandoned...
      where
        vb = shift 1 v
```

なんかおかしい。

うまくやれないのかな。頂点N個のとき、0から2^N-1までの数を、ビットで対応させるのではなくて、0が空集合、v=1からNが頂点vの一点集合、N+1～N+N\(N-1\)/2が大きさ2の集合、みたいに相互に対応付ける方法。面倒くさそうだね。

---

いろいろごちゃごちゃしたけど、なんかわかった。というか、S=0とv=0は無関係だ。  
全てのSについて、かつ、全てのSに含まれないvについて計算する、全てのSに含まれるuについてd\[S\]\[u\] + cost\(u,v\)の最小値を、それをd\[S+v\]\[v\]とする、ということ。  
d\[S\]\[v\]に入っている値は、0から開始して、Sに含まれる頂点を1度ずつ辿って、最後にvにたどり着く経路。vはSに含まれているが、v=0ならハミルトン閉路、さもなくば開路。

