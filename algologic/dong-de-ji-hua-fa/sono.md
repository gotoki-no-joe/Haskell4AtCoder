# その形態

動的計画法は、問題が再帰的、つまり様々なconfigurationでの部分問題の解を集めて最終的な解が作られるときに、同じ（ような）部分問題に関する問い合わせを一度だけで済ませることで計算量を減らす手法といえる。

## 集めるDP

理想的には、基底部の解を初めに定めて、そこからボトムアップに、一つのconfigurationについては一度で計算が済み、次に計算するべきconfigurationが数え上げることができると、正格評価で見通しよく計算できる。

特に、一つ前の結果だけから次の結果が計算できると、とても都合がよい。  
それは、関数が再帰的に $$f(0) = C, f(n) = G(f(n-1), n)$$と定義されるとき、$$f(n) = \textrm{foldl} \; G \;C \; [1..n]$$あるいは 

```javascript
function f(n) {
  let r = C;
  for (let i = 1; i <= n; i++) { r = G(r,i); }
  return r;
}
```

と反復的に定義できるということである。これをDPだという人もあまりいない気もするが。

もう少し面倒な場合だと、再帰部が「それ以前の全ての値」を参照して、$$f(n) = G([f(0),\dots,f(n-1)],n)$$のようになる。この場合、全ての値を覚えておく必要があるので、配列を使って次のようになる。

```javascript
function f(n) {
  const a = new Array(n+1);
  a[0] = C;
  for (let i = 1; i <= n; i++) { a[i] = G(a,i); }
  return a[n];
}
```

この配列の各要素は、iが到達したそのときに一度だけ設定され、それ以降は上書きされない、const的な配列である。なのでpureな計算の一種なのだが、Haskell化するのは難儀である。

```haskell
f n = flist !! n
  where
    flist = C : [ G (take i flist) i | i <- [1..] ]
```

Gにtakeせずに渡すと、Gがバグっていたとき自己参照してハングアップするし、nより手前の要素だけをGが使っていることを示せない。そしてGの中でflistの要素がランダムアクセスできないのがカッコ悪い。Vectorなら末尾への追加ができるが、O\(n\)かかる。Mutable Vectorで初めから領域確保すると、Mutable Vectorなので上書きしていないという潔癖さを示せない。Arrayで書くと

```haskell
f n = a ! n
  where
    a = listArray (0,n) $ C : [ G a i | i <- [1..n] ]

-- Gの中では a!0 から a!n-1 までしかアクセスしない
```

いずれにせよ、このように「あるconfigurationについては一度だけ値を定める、そのときに既に計算済みの部分問題の解を利用する」というスタイルを「集めるDP」と呼ぶことかできそう。pureなDP。

## 配るDP

そうでないスタイルのDPも、（命令的パラダイムだと）考えられる。  
あるconfigurationに対する解があるとき、それを部分問題とするより上位のconfigurationに対する解の候補が構成できる。それを配列の要素に上書き更新することで、最終的には（部分問題全てを舐めると）上位のconfigurationの解が得られるという流れ。

「アルゴリズムロジック」での巡回セールスマン問題の解がこの形式になっていた。  
下位のconfigurationから上位のconfigurationに情報を「配る」ことから「配るDP」と呼ぶようだ。

抽象化すると、関数Gが部分問題の解をある演算opを続けて適用するような計算、つまり

```javascript
function G(al,n) { return al.reduce(op,I); }
```

と定義される問題のとき、

```javascript
function f(n) {
  const a = new Array(n+1);
  a.fill(I);
  a[0] = C;
  for (let i = 0; i < n; i++) { // 確定している要素iから配る
    for (let j = i+1; j <= n; j++) { // 要素iを配る先は要素j
      a[j] = op(a[j], g[i]);
    }
  }
  return a[n];
}
```

とできるという話。

pureなコードでは配るDPは書きにくい。  
こちらのスタイルで定義されるDPも、集めるDPに変形することはできる。  
配るDPのまま実現しようとすると、次のように書けなくもない。  
なお初期値の設定のために op C I = C である必要がある。

```haskell
f n = a ! n
  where
    a = accumArray op I (0,n) $
        (0,C) :
        [(j, a[i]) | i <- [0..n-1], j <- [i+1..n]]
```

a\[j\]が何に依存するのかを明示的に計算しなくてよいのが楽だが、遅延評価をほどくところにとても負荷がかかりそう。そしてaccumArrayがそもそもpureっぽくない。

