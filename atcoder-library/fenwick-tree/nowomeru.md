# 配列区間の合計を求める

一次元に並んだ数の、ある区間の和を求める方法について。

## 愚直な方法

リスト`xs`の`a`要素めから`b`要素めまでの和は

```haskell
sumspan xs a b = sum $ drop a $ take b xs
```

計算量は$$O(n)$$である。これを毎回支払うのは大きい。  
格納先をリストでなくmutable vectorにした場合、要素の変更は$$O(1)$$で可能ではある。

## 区間和を用いる方法

リスト`xs`について、先頭から$$n$$個の和は、順に足せばできるので$$O(n^2)$$ではなく$$O(n)$$で作れる。これを$$O(1)$$でランダムアクセスできるベクタに保存しておく。

```haskell
spanv = V.froList $ scanl (+) 0 xs
```

このベクタの位置$$n$$には、先頭から$$n$$要素の和がある。元のリストの`a`要素めから`b`要素めまでの和は、先頭から`b`要素めまでの和から、先頭から`a-1`要素めまでの和を引けばよいので、$$O(1)$$で求められる。

リストの内容が固定ならこれが最適であるが、リストの要素を修正したい場合は、その要素以降の区間和全てに同じ修正を施す必要があるため、$$O(n)$$かかってしまう。

## フェニック木

奇妙な二分木を用いて、要素の修正と区間の合計の両方を$$O(\log n)$$で可能にするデータ構造である。

