# ナップザック問題(無限個,整数)

「定本　Cプログラマのためのアルゴリズムとデータ構造」によると、ナップザック問題は

* 個々の品物の在庫数（1つ限り、上限あり、任意個選択可能）
* ナップザックの容量、価値の扱いやすさ（自然数あるいは整数か、小数点付きの数か）

で設定の異なる問題になるとある。また後者の、整数で扱えない設定は動的計画法には合わず、バックトラックでしか解けない、とある。（0/1ナップザック問題を解いた方式なら、整数でない価値にも対応できるような気がするが。容積または重量の方は確かにそうだろう。）

商品在庫数無限の設定でのアルゴリズムを、「定本」と「C言語による最新アルゴリズム事典」で理解した。まず商品に番号をつける。「k番以下の商品を考慮した結果」の状況をk=0～全てまで回す。状態は、容量v=0～問題の容量までの全てのナップザックについて、最適に詰めた場合の価値の合計を持っておく。

* $$k=0$$の、一つも商品を使えない場合、全てのナップザックについて、最大価値は0である。
*   $$i-1$$番まで考慮した結果のナップザックの価値表$$val[v]$$と、$$i$$番の品物の容量$$v_i$$、価値$$w_i$$があるとき、$$i$$番まで考慮した結果のナップザックの価値表$$val'[v]$$は、

    $$val'[v] = val[v] \; \textrm{if} \; v < v_i$$　$$v_i$$より小さいナップザックには、そもそも$$i$$番の品物は入れられない

    $$val'[v] = \max(val[v], val'[v-v_i] + w_i)$$　$$i$$番の商品をひとつ入れて、残りの容量$$v-v_i$$に最適に詰める方法は$$val'[v-v_i]$$が知っている。

    こうすると、$$i$$番の商品が数珠つなぎに使われて、入るだけ入れる方法が選ばれる。
* 最終的に全ての品物を考慮した結果の、最大の容量の場合が求める答えである。

表に「最後に使った品物」の番号$$k$$を付記して全ての表を残しておくと、最大価値以外の情報が復元できるという。そのメモに書かれた品物を1つ使い、残りは、max関数が選んだ方を見に行く、でナップザックの内容が全て復元できるという事か。

価値の最大値のみ、表は前回と今回だけを見て求めるタイプを実装する。

```haskell
import Control.DeepSeq

compute :: Int -> [[Int]] -> Int
compute vmax vws = last wsn
  where
    ws0 = replicate (succ vmax) 0
    wsn = foldl step ws0 vws

step ws (v:w:_) = force ws1
  where
    (as,bs) = splitAt v ws
    ws1 = as ++ zipWith max bs (map (w +) ws1)
```

$$val'(v)$$を求めるのに、既に$$i$$番目の品物が入っている可能性のあるナップザック$$val'[v-v_i]$$を使うと、品物が無限個ある設定になる。この図式をよく考えると、それの代わりに、$$i$$番目の品物を1つだけ使うか使わないかなら、まだ入っていないナップザック$$val[v-v_i]$$（ダッシュなし、前回の情報）を使うところだけを変えればよいとわかる。品物の個数に上限があるときは同様に、$$val[v-2v_i] + 2w_i, val[v-3v_i] + 3w_i, \dots$$の中から最大値を選べばできるが、品物1つだけ版で品物のコピーを作った方が楽そうである。

ということで品物1つ版は（以前の版よりずっと）単純に書ける。

```haskell
import Control.DeepSeq

compute :: Int -> [[Int]] -> Int
compute vmax vws = last wsn
  where
    ws0 = replicate (succ vmax) 0
    wsn = foldl step ws0 vws

step ws (v:w:_) = force ws1
  where
    (as,bs) = splitAt v ws
    ws1 = as ++ zipWith max bs (map (w +) ws)
```
