# 40.しゃくとり法 \(yot net\)

> 非負数列$$\{a_1,\dots,a_n\}$$がある。これの連続する区間$$a_i,\dots,a_j \; (i \leq j)$$の和を$$\displaystyle S(i,j) = \sum_{k=i}^j a_k$$とする。  
> $$S(i,j)$$が指定した上限$$M$$を超えない最長の区間の長さ$$j-i+1$$を求めよ。

というような問題に対して、「全ての$$i = 1,\dots,n$$に対して、全ての$$j = i,\dots,n$$に対して$$S(i,j)$$を求めては$$M$$以下かを調べる」という愚直な方法

```text
maxlen = 0
for (i = 1; i <= n; i++)
  for (j = i; j <= n; j++)
    sum = 0
    for (k = i; k <= j; k++)
      sum += a[k]
    if sum <= m
      maxlen = max(maxlen, j-i+1)
```

はあまりにも愚直である。$$S(i,j+1) = S(i,j) + a_{j+1}$$であることを利用して、前のループの結果を使うことができる。

```text
maxlen = 0
for (i = 1; i <= n; i++)
  sum = 0
  j = i
  while (sum <= M && j <= n)
    sum += a[j++]
  if sum > M
    j--
  maxlen = max(maxlen, j-i+1)
```

さてここで、ある$$i$$について計算が終わって$$i+1$$に進むとき、$$j=i$$から総和を取り直すのも無駄である。$$S(i+1,j) = S(i,j) - a_i$$であり、$$a_i \geq  0$$より$$S(i+1,i+1) \leq \dots \leq S(i+1,j)$$また$$S(i+1,j) \leq S(i,j) \leq M$$であるため、$$i+1$$から始まる区間で$$j$$より手前で終わるものについて改めて調べる必要はない。

```text
maxlen = 0
j = 1
sum = a[1]
for (i = 1; i <= n; i++)
  while (sum <= M && j < n)
    sum += a[++j]
  if sum > M
    sum -= a[j--]
  maxlen = max(maxlen, j-i+1)
```

ループの初回で$$i=1$$に対して$$j$$が伸びるだけ伸びた後は、$$i$$を1増やして区間が短くなる度に、いくから$$j$$を増やして区間を可能なだけ伸ばす、という「しゃくとり虫」のような動きをする。

関数型でもこのアイデアを同様に実現できる。

```haskell
maxlen :: Int -> [Int] -> Int
maxlen m xs = maximum $ loop 0 0 xs xs
  where
    loop len sum xxs@(x:xs) yys@(y:ys)
      | m >= sum + y =       loop (len + 1) (sum + y) xxs ys -- もう一つ足せる
      | otherwise    = len : loop (len - 1) (sum - x) xs yys -- もう足せない
    loop len _ _ [] = [len]
```

命令型を含め、正常系はこれでよいのだが、一つのaiでmを超えてしまうような場合など、左側が右側に追いついてしまう場合で不具合があるようだ。もう少し勉強しないと。

